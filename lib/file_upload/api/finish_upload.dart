// DO NOT EDIT THIS FILE.  IT IS GENERATED AUTOMATICALLY AND YOUR CHANGES WILL BE OVERWRITTEN

import 'dart:convert';

import 'package:sunny_dart/helpers/lists.dart';
import 'package:dartxx/json_path.dart';
import 'package:sunny_sdk_core/mverse/m_model.dart';

import '../mixins/sunny_main.dart'; // ignore: unused_import, directives_ordering

import 'e_tag_response.dart'; // ignore: unused_import, duplicate_import, directives_ordering

class FinishUpload extends FinishUploadBase with FinishUploadMixin {
  FinishUpload(Map<String, dynamic> wrapped, {MSchemaRef mtype = FinishUploadRef, bool update = true})
      : super(wrapped, mtype: mtype, update: update);

  factory FinishUpload.fromJson(wrapped) => wrapped is FinishUpload ? wrapped : FinishUpload(wrapped as Map<String, dynamic>);

  FinishUpload.of({String? keyName, List<ETagResponse>? parts})
      : super.of(
          keyName: keyName,
          parts: parts,
        );

  @override
  String? get keyName => _keyName;
  @override
  set keyName(String? keyName) {
    this._keyName = keyName;
    wrapped['keyName'] = jsonLiteral(keyName);
  }

  @override
  List<ETagResponse>? get parts => _parts;
  @override
  set parts(List<ETagResponse>? parts) {
    this._parts = parts;
    wrapped['parts'] = jsonLiteral(parts);
  }
}

abstract class FinishUploadBase extends MModel {
  FinishUploadBase(Map<String, dynamic> wrapped, {MSchemaRef mtype = FinishUploadRef, bool? update})
      : super(wrapped, mtype: mtype, update: false) {
    if (update == true) takeFromMap(wrapped, copyEntries: false);
  }

  FinishUploadBase.fromJson(wrapped) : this(wrapped as Map<String, dynamic>, update: true);
  FinishUploadBase.of({String? keyName, List<ETagResponse>? parts}) : super(<String, dynamic>{}, mtype: FinishUploadRef) {
    if (keyName != null) this.keyName = keyName;
    if (parts != null) this.parts = parts;
  }

  String? _keyName;

  /// Property getter and setter for keyName:
  String? get keyName;
  set keyName(String? keyName);

  List<ETagResponse>? _parts;

  /// Property getter and setter for parts:
  List<ETagResponse>? get parts;
  set parts(List<ETagResponse>? parts);

  @override
  String toString() => json.encode(wrapped).toString();
  dynamic toJson() => wrapped;

  @override
  operator [](key) {
    switch (key) {
      case "keyName":
        return this.keyName;
      case "parts":
        return this.parts;
      default:
        return wrapped[key];
    }
  }

  @override
  operator []=(String key, value) {
    switch (key) {
      case "keyName":
        this.keyName = value as String;
        break;
      case "parts":
        this.parts = value as List<ETagResponse>;
        break;
      default:
        wrapped[key] = value;
    }
  }

  @override
  void takeFrom(source) {
    if (source == null) return;
    if (source is Map<String, dynamic>) {
      takeFromMap(source, copyEntries: true);
    } else if (source is MModel) {
      takeFromMap(source.wrapped, copyEntries: true);
    } else {
      throw ("Can't take values from unknown type ${source.runtimeType}");
    }
  }

  @override
  void takeFromMap(Map<String, dynamic>? from, {bool copyEntries = true}) {
    if (from == null) return;

    super.takeFromMap(from, copyEntries: copyEntries);
    for (final entry in from.entries) {
      final key = entry.key;
      final value = entry.value;
      if (value == null) continue;
      switch (key) {
        case "keyName":
          _keyName = value as String;
          break;
        case "parts":
          _parts = toList(value, (item) => ETagResponse.fromJson(item));
          break;
        default:
          break;
      }
    }
  }

  @override
  FinishUpload clone() => this as FinishUpload;

  @override
  Set<String> get mfields => FinishUploadFields.values;
}

class FinishUploadFields {
  static const keyName = "keyName";
  static const parts = "parts";
  static const Set<String> values = {keyName, parts};
}

class FinishUploadPaths {
  static const JsonPath<String> keyName = JsonPath.internal(["keyName"], "/keyName");
  static const JsonPath<List<ETagResponse>> parts = JsonPath.internal(["parts"], "/parts");
  static final Set<JsonPath> values = {keyName, parts};
}

const FinishUploadRef = MSchemaRef("mverse", "sunnyMain", "finishUpload", "0.0.1", "ephemeral");
