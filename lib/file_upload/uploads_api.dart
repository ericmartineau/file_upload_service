/// DO NOT EDIT THIS FILE.  IT IS GENERATED AUTOMATICALLY AND YOUR CHANGES WILL BE OVERWRITTEN
import 'dart:convert'; // ignore: unused_import

import 'package:sunny_sdk_core/api/api_client.dart';
import 'package:sunny_sdk_core/request_builder.dart';

import 'api/abort_upload.dart'; // ignore: unused_import
import 'api/e_tag_response.dart'; // ignore: unused_import
import 'api/finish_upload.dart'; // ignore: unused_import
import 'api/start_upload.dart'; // ignore: unused_import
import 'api/upload_request.dart'; // ignore: unused_import

/// DO NOT EDIT THIS FILE.  TO ADJUST THIS CLASS, USE [ UploadsApiMixin ]
///
/// The final API is constructed by:
///
/// * taking the [UploadsApiBase] class
/// * applying a mixin [ UploadsApiMixin ]] (which allows us to inject other convenience functions)
///      The mixin lives outside of the code generator, so it's used to do any manual tweaking
/// * Applying the [SignalingApiMixin], so events automatically propagate
///
class UploadsApi extends UploadsApiBase implements IUploadsApi {
  UploadsApi(ApiClient apiClient) : super(apiClient);
}

///
/// DO NOT MODIFY
///
/// GENERATED API OPERATIONS
///
abstract class UploadsApiBase {
  final ApiClient apiClient;

  UploadsApiBase(this.apiClient);

  // ignore: avoid_renaming_method_parameters
  Future<bool> cancelUpload(String uploadId, {AbortUpload? body}) async {
    final builder = RequestBuilder();
    builder.body = body;

    // create path and map variables
    // create path and map variables
    builder.path = "/uploads/{uploadId}/abort";
    builder.pathParams["uploadId"] = Uri.encodeComponent(uploadId);
    List<String> contentTypes = ["application/json"];
    String contentType = contentTypes.isNotEmpty ? contentTypes[0] : "application/json";
    builder.contentType = contentType;
    builder.basePath = apiClient.basePaths["sunnyMain"];
    builder.authNames = ["Bearer"];

    builder.method = HttpMethod.POST;

    final response = await apiClient.invokeRequest(builder);
    final value = apiClient.decodeAs<bool>(response.body);
    return value!;
  }

  // ignore: avoid_renaming_method_parameters
  Future<bool> completeUpload(String uploadId, {FinishUpload? body}) async {
    final builder = RequestBuilder();
    builder.body = body;

    // create path and map variables
    // create path and map variables
    builder.path = "/uploads/{uploadId}";
    builder.pathParams["uploadId"] = Uri.encodeComponent(uploadId);
    List<String> contentTypes = ["application/json"];
    String contentType = contentTypes.isNotEmpty ? contentTypes[0] : "application/json";
    builder.contentType = contentType;
    builder.basePath = apiClient.basePaths["sunnyMain"];
    builder.authNames = ["Bearer"];

    builder.method = HttpMethod.POST;

    final response = await apiClient.invokeRequest(builder);
    final value = apiClient.decodeAs<bool>(response.body);
    return value!;
  }

  // ignore: avoid_renaming_method_parameters
  Future<StartUpload> startUpload({UploadRequest? body, Map? mediaParams}) async {
    final builder = RequestBuilder();
    builder.body = {
      ...?body?.wrapped,
      if(mediaParams!=null) "media": mediaParams,
    };
    // create path and map variables
    // create path and map variables
    builder.path = "/uploads";
    List<String> contentTypes = ["application/json"];
    String contentType = contentTypes.isNotEmpty ? contentTypes[0] : "application/json";
    builder.contentType = contentType;
    builder.basePath = apiClient.basePaths["sunnyMain"];
    builder.authNames = ["Bearer"];

    builder.method = HttpMethod.POST;

    final response = await apiClient.invokeRequest(builder);
    final value = apiClient.decodeAs<StartUpload>(response.body);
    return value!;
  }

  // ignore: avoid_renaming_method_parameters
  Future<ETagResponse> uploadPart(String uploadId, {Object? body, int? length, String? pathname, String? partnumber}) async {
    final builder = RequestBuilder();
    builder.body = body;

    // create path and map variables
    // create path and map variables
    builder.path = "/uploads/{uploadId}/parts";
    builder.pathParams["uploadId"] = Uri.encodeComponent(uploadId);
    builder.headerParams["pathname"] = pathname;
    builder.headerParams["partnumber"] = partnumber;
    builder.contentType = "application/octet-stream";
    if (length != null) {
      builder.headerParams["Content-Size"] = length.toString();
    }
    builder.basePath = apiClient.basePaths["sunnyMain"];
    builder.authNames = ["Bearer"];

    builder.method = HttpMethod.POST;

    final response = await apiClient.invokeRequest(builder);
    final value = apiClient.decodeAs<ETagResponse>(response.body);
    return value!;
  }

  // ignore: avoid_renaming_method_parameters
  Future<String?> findMedia({required String mediaType, required String filePath, required int fileSize}) async {
    final builder = RequestBuilder();

    // create path and map variables
    // create path and map variables
    builder.path = "/uploads/{mediaType}/{mediaId}";
    builder.pathParams["mediaType"] = Uri.encodeComponent(mediaType);
    builder.pathParams["mediaId"] = filePath;
    builder.queryParams["fileSize"] = fileSize;
    builder.basePath = apiClient.basePaths["sunnyMain"];
    builder.authNames = ["Bearer"];
    builder.contentType = "application/json";
    builder.method = HttpMethod.GET;

    final response = await apiClient.invokeRequest(builder);
    return json.decode(response.body) as String?;

  }
}

abstract class IUploadsApi {
  Future<ETagResponse> uploadPart(String uploadId, {Object? body, int? length, String? pathname, String? partnumber});
  Future<bool> completeUpload(String uploadId, {FinishUpload? body});
  Future<StartUpload> startUpload({UploadRequest? body, Map? mediaParams});
  Future<bool> cancelUpload(String uploadId, {AbortUpload? body});
  Future<String?> findMedia({required String mediaType, required String filePath, required int fileSize}) async => null;
}
